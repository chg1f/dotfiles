#!/usr/bin/env bash
# shellcheck shell=bash
set -euo pipefail

# ============================================================
# chezmoi-package (bash-compatible, concise code tree)
# Purpose: daily operations helper for chezmoi-managed dotfiles.
# Repo: https://github.com/chg1f/dotfiles
#
# Key definitions:
# - bootstrap: idempotent machine bootstrap (install required tools).
# - update: update metadata only; no local environment changes.
# - apply: use metadata to sync local environment (apply config, install/update only).
# - prune: clean local environment based on applied metadata.
# - commit: save local environment state into metadata.
# - push: push metadata to the remote repo.
# ============================================================

# DEBUG: enable debug mode (0/1).
DEBUG="${DEBUG:-0}"
# VERBOSE: enable verbose mode (0/1).
VERBOSE="${VERBOSE:-0}"
# CONFIRM: auto-confirm prompts (0/1).
CONFIRM="${CONFIRM:-0}"
# COMMENT: commit message format for repo_commit (printf-style).
COMMENT="${COMMENT:-source %s sync %d files}"
# BRANCH: target git branch for chezmoi operations.
BRANCH="${BRANCH:-main}"
# EXCLUDES: comma-separated components to exclude.
EXCLUDES="${EXCLUDES:-}"

# GITHUB_USERNAME: GitHub username for chezmoi init bootstrap.
GITHUB_USERNAME="${GITHUB_USERNAME:-chg1f}"
# TMUX_PLUGIN_MANAGER_PATH: absolute path to tmux plugin manager root.
TMUX_PLUGIN_MANAGER_PATH="${TMUX_PLUGIN_MANAGER_PATH:-${XDG_DATA_HOME:-$HOME/.local/share}/tmux/plugins}"
# ZIM_HOME: path to zimfw installation root.
ZIM_HOME="${ZIM_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/zim}"
# HOMEBREW_BUNDLE_FILE: path to Brewfile for brew bundle operations.
HOMEBREW_BUNDLE_FILE="${HOMEBREW_BUNDLE_FILE:-${XDG_CONFIG_HOME:-$HOME/.config}/Brewfile}"

# _usage: print CLI help text and exit guidance.
# - includes flags, env vars, examples, and excludes.
_usage() {
	cat <<EOF
Usage:
	chezmoi-package [-b|--bootstrap] [-u|--update] [-a|--apply] [-x|--prune] [-c|--commit] [-p|--push] [--help] [--verbose] [--debug] [--confirm] [--branch BRANCH] [--exclude EXCLUDE[ EXCLUDE...]]
	Description: daily operations for the chezmoi-managed dotfiles repo at https://github.com/chg1f/dotfiles

Flags:
	--bootstrap, -b
		idempotent machine bootstrap (install required tools, like homebrew/chezmoi/mise).

	--update, -u
		update metadata only; no local environment changes.

	--apply, -a
		use metadata to sync local environment (apply config, install/update only).

	--prune, -x
		clean local environment based on applied metadata.

	--commit, -c
		save local environment state into metadata.

	--push, -p
		push metadata to the remote repo.

	--help
		print this help message and exit.

	--verbose
		details of operations will be printed.

	--debug
		enable debug mode (more verbose output and tracing).

	--confirm
		auto-confirm all prompts (diff still shown).

	--branch BRANCH
		specify bootstrap, update, apply, commit, push branch/name.
		default: main

	--exclude exclude[ exclude...]
		comma-separated list of components to exclude from all operations.
		repeatable.

Environment Variables:
	VERBOSE (1)     same as --verbose
	DEBUG (1)       same as --debug
	CONFIRM (1)     same as --confirm
	COMMENT         commit message format for repo_commit (printf-style)
	BRANCH          same as --branch (default: main)
	EXCLUDES        same as --exclude
	GITHUB_USERNAME your GitHub username (for bootstrap repo)
	ZIM_HOME        path to zimfw installation root
	HOMEBREW_BUNDLE_FILE
		path to Brewfile for brew bundle operations

	TMUX_PLUGIN_MANAGER_PATH
		path to tpm installation root (must include /tpm).
		if unset, tpm operations are skipped.

Examples:
	daily use:
	  chezmoi-package -cpua
	  chezmoi-package -cpuax
	  chezmoi-package -bcpuax

	client bootstrap:
	  GITHUB_USERNAME="chg1f" chezmoi-package -b

Excludes:
	chezmoi, brew, mise, mas, tpm, nvim, zimfw
EOF
}

# _log: write a structured log line to stderr.
# - args: <stage> <component> <message...>
_log() {
	local stage="${1:-}"
	local comp="${2:-}"
	shift 2 || true
	printf "[%s] %s(%s): %s\n" "$(date '+%F %T')" "$comp" "$stage" "$*" >&2
}

# _die: log a fatal error and exit non-zero.
_die() {
	_log "${1:-}" "${2:-error}" "$*"
	exit 1
}

# _has: check if a command exists on PATH.
_has() {
	command -v "$1" >/dev/null 2>&1
}

# _exclude: return success if a component is excluded via EXCLUDES list.
_exclude() {
	case ",${EXCLUDES}," in
	*,"$1",*) return 0 ;;
	*) return 1 ;;
	esac
}

# _comment: format commit message from COMMENT template.
# - uses md5(user@host) and changed file count.
_comment() {
	local count="$1"
	local user="${USER:-unknown}"
	local host
	host="$(hostname -s 2>/dev/null || hostname 2>/dev/null || echo unknown)"

	local hash=""
	if command -v md5sum >/dev/null 2>&1; then
		hash="$(printf "%s" "${user}@${host}" | md5sum | awk '{print $1}')"
	elif command -v md5 >/dev/null 2>&1; then
		hash="$(printf "%s" "${user}@${host}" | md5 -q)"
	fi
	printf "$COMMENT" "$hash" "$count"
}

# git_stash: stash current repo changes before apply/commit steps.
# - creates a named stash; no-op if nothing to stash.
git_stash() {
	if [[ -n "$(chezmoi git -- status --porcelain=v1)" ]]; then
		local msg="chezmoi-package pre-commit $(date '+%F %T')"
		_log "stash" "chezmoi" "pre-commit $msg"
		_run chezmoi git -- stash push -u -m "$msg"
	fi
}

# git_commit: commit chezmoi repo changes if any.
# - uses COMMENT template with user/host hash and file count.
git_commit() {
	_log "commit" "chezmoi" "git diff --stat"
	_run chezmoi git -- diff --stat || true

	if [[ -n "$(chezmoi git -- status --porcelain=v1)" ]]; then
		local count
		count="$(chezmoi git -- status --porcelain=v1 | wc -l | awk '{print $1}')"
		local msg
		msg="$(_comment "$count")"
		_run chezmoi git -- add -A
		_run chezmoi git -- commit -m "$msg"
		_log "commit" "chezmoi" "commit -m \"$msg\""
	fi
}

# _run: run a command and emit only chezmoi-package logs when not verbose.
# - args: <cmd...>
_run() {
	if ((VERBOSE)); then
		"$@"
		return $?
	fi

	"$@" >/dev/null 2>&1
}

# _confirm: show diff (optional) and prompt unless CONFIRM=1.
# - args: <message> [path]
# - uses [ynq] prompt; y=yes, n=no, q=quit (exit 0).
_confirm() {
	local message="${1:-Continue?}"
	local path="${2:-}"

	if [[ -n "$path" ]]; then
		if ! chezmoi diff -- "$path" | grep -q .; then
			# _log "confirm" "$path" "no changes"
			return 1
		fi
		chezmoi diff -- "$path" || true
	else
		if ! chezmoi diff | grep -q .; then
			# _log "confirm" "chezmoi" "no changes"
			return 1
		fi
		chezmoi diff || true
	fi

	if ((CONFIRM)); then
		return 0
	fi
	local reply=""
	while true; do
		printf "%s [ynq]: " "$message" >/dev/tty
		read -r reply </dev/tty || true
		case "$reply" in
		[Yy]) return 0 ;;
		[Nn])
			_log "$path" "confirm" "declined"
			return 1
			;;
		[Qq])
			_log "$path" "confirm" "quit"
			exit 0
			;;
		esac
	done
}

# git_checkout: checkout target branch inside the chezmoi repo.
# - no-op if branch empty, excluded, or chezmoi missing.
git_checkout() {
	local branch="${1:-}"
	[[ -n "$branch" ]] || return 0
	_exclude chezmoi && return 0
	_has chezmoi || return 0
	local current
	current="$(chezmoi git -- rev-parse --abbrev-ref HEAD 2>/dev/null || echo unknown)"
	if [[ "$current" != "$branch" ]]; then
		_log "chezmoi" "branch" "git checkout $branch"
		_run chezmoi git -- checkout "$branch" || true
	fi
}

# bootstrap: idempotent machine bootstrap (install required tools).
# - ensures Homebrew and base tools, then initializes chezmoi.
bootstrap() {
	if ! _has brew; then
		_log "bootstrap" "brew" "installing"
		_run bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
		if [[ -x /opt/homebrew/bin/brew ]]; then
			eval "$(/opt/homebrew/bin/brew shellenv)"
		elif [[ -x /usr/local/bin/brew ]]; then
			eval "$(/usr/local/bin/brew shellenv)"
		fi
		_has brew || _die "brew installed but not on PATH; restart shell or set PATH"
	fi
	_log "bootstrap" "brew" "installed"
	if ! _exclude git && ! _has git; then
		_log "bootstrap" "git" "installing"
		_run brew install git
	fi
	_log "bootstrap" "git" "installed"
	if ! _exclude chezmoi && ! _has chezmoi; then
		_log "bootstrap" "chezmoi" "installing"
		_run brew install chezmoi

		_log "bootstrap" "chezmoi" "initializing"
		_run chezmoi init --apply --branch "$BRANCH" "$GITHUB_USERNAME"
	fi
	_log "bootstrap" "chezmoi" "installed"
	if ! _exclude mise && ! _has mise; then
		_log "bootstrap" "mise" "installing"
		_run brew install mise
	fi
	_log "bootstrap" "mise" "installed"
}

# update: update metadata only; no local environment changes.
# - refreshes remote refs and tool registries.
update() {
	# update_chezmoi: fetch remote refs for the chezmoi repo.
	# - uses git fetch --all --prune via chezmoi.
	update_chezmoi() {
		_log "update" "chezmoi" "git fetch --all --prune"
		if ((VERBOSE)); then _run chezmoi git -- fetch -v --all --prune; else _run chezmoi git -- fetch --all --prune; fi
	}
	# update_brew: refresh Homebrew metadata.
	# - runs brew update.
	update_brew() {
		_log "update" "brew" "update"
		_run brew update
	}
	# update_mise: refresh mise registry and plugin metadata.
	# - tolerates errors (registry/plugins may be optional).
	update_mise() {
		_log "update" "mise" "plugins update"
		_run mise plugins update || true
	}

	git_checkout "$BRANCH"
	if ! _exclude chezmoi && _has chezmoi; then update_chezmoi; fi
	if ! _exclude brew && _has brew; then update_brew; fi
	if ! _exclude mise && _has mise; then update_mise; fi
}

# apply: use metadata to sync local environment (apply config, install/update only).
# - no deletions; installs/upgrades based on current metadata.
apply() {
	# chezmoi_apply: pull repo changes, show diff, prompt, then apply config.
	# - requires user confirmation before apply.
	chezmoi_apply() {
		_log "apply" "chezmoi" "git pull --ff-only"
		if ((VERBOSE)); then _run chezmoi git -- pull -v --ff-only; else _run chezmoi git -- pull --ff-only; fi

		_log "apply" "chezmoi" "init"
		_confirm "Regenerate chezmoi config?" && _run chezmoi init || true

		_log "apply" "chezmoi" "confirm to apply managed files"
		local file=""
		while IFS= read -r -d '' file; do
			[[ -n "$file" ]] || continue
			if _confirm "Apply chezmoi changes?" "$file"; then
				_run chezmoi apply -- "$file"
			fi
		done < <(chezmoi managed --include=files --nul-path-separator -p absolute)
	}
	# brew_apply: upgrade brew packages and sync Brewfile bundle.
	# - runs brew upgrade/upgrade --cask and brew bundle if Brewfile exists.
	brew_apply() {
		_log "apply" "brew" "upgrade"
		_run brew upgrade || true
		_log "apply" "brew" "upgrade --cask"
		_run brew upgrade --cask || true

		if [[ -f "$HOMEBREW_BUNDLE_FILE" ]]; then
			_log "apply" "brew" "bundle --file $HOMEBREW_BUNDLE_FILE"
			if ((VERBOSE)); then _run brew bundle --file "$HOMEBREW_BUNDLE_FILE" --verbose; else _run brew bundle --file "$HOMEBREW_BUNDLE_FILE"; fi
		fi
	}
	# mas_apply: upgrade App Store apps via mas.
	# - runs mas upgrade.
	mas_apply() {
		_log "apply" "mas" "upgrade"
		_run mas upgrade || true
	}
	# mise_apply: install tools listed by mise.
	# - runs mise install.
	mise_apply() {
		_log "apply" "mise" "install"
		_run mise install
		_run mise upgrade
	}
	# zimfw_apply: install/update zimfw plugins using binary or sourced script.
	# - prefers zimfw binary; falls back to sourcing zimfw.zsh.
	zimfw_apply() {
		_log "apply" "zimfw" "install"
		_run zimfw install
		_log "apply" "zimfw" "update"
		_run zimfw update
	}
	# tpm_apply: update tmux plugin manager and its plugins.
	# - requires TMUX_PLUGIN_MANAGER_PATH and repo at that path.
	tpm_apply() {
		local install="$TMUX_PLUGIN_MANAGER_PATH/bin/install_plugins"
		if [[ -x "$install" ]]; then
			_log "apply" "tpm" "install plugins"
			# shellcheck disable=SC2086
			_run "$install" || true
		fi

		local update="$TMUX_PLUGIN_MANAGER_PATH/bin/update_plugins"
		if [[ -x "$update" ]]; then
			_log "apply" "tpm" "update plugins"
			# shellcheck disable=SC2086
			_run "$update" all || true
		fi

	}
	# nvim_apply: sync Neovim plugins headlessly (Lazy.nvim).
	# - runs nvim --headless "+Lazy! sync" "+qa".
	nvim_apply() {
		_log "apply" "nvim" 'headless "+Lazy! sync" "+qa"'
		# shellcheck disable=SC2086
		_run nvim --headless "+Lazy! sync" "+qa"
	}

	git_stash
	git_checkout "$BRANCH"
	if ! _exclude chezmoi && _has chezmoi; then chezmoi_apply; fi
	if ! _exclude brew && _has brew; then brew_apply; fi
	if ! _exclude mas && _has mas; then mas_apply; fi
	if ! _exclude mise && _has mise; then mise_apply; fi
	if ! _exclude zimfw && _has zimfw; then zimfw_apply; fi
	if ! _exclude tpm; then tpm_apply; fi
	if ! _exclude nvim && _has nvim; then nvim_apply; fi
}

# prune: clean local environment based on applied metadata.
# - removes unused packages/versions and stale plugins.
prune() {
	# brew_prune: remove unused brew deps and cleanup caches.
	# - runs brew autoremove and brew cleanup.
	brew_prune() {
		_log "prune" "brew" "autoremove"
		_run brew autoremove
		_log "prune" "brew" "cleanup"
		_run brew cleanup
	}
	# mise_prune: remove unused mise tool versions.
	# - runs mise prune -y.
	mise_prune() {
		_log "prune" "mise" "prune"
		if ((CONFIRM)); then _run mise prune -y; else _run mise prune; fi
	}
	# tpm_prune: clean tmux plugins not in config.
	# - requires clean_plugins executable under TPM path.
	tpm_prune() {
		local clean="$TMUX_PLUGIN_MANAGER_PATH/tpm/bin/clean_plugins"
		if [[ -x "$clean" ]]; then
			_log "prune" "tpm" "clean plugins"
			# shellcheck disable=SC2086
			_run "$clean"
		fi

	}

	if ! _exclude brew && _has brew; then brew_prune; fi
	if ! _exclude mise && _has mise; then mise_prune; fi
	if ! _exclude tpm; then tpm_prune; fi
}

# commit: save local environment state into metadata.
# - captures tool state into repo files and commits if needed.
commit() {
	# _brew_commit: dump Brewfile and add it to chezmoi.
	# - includes taps, formulae, casks, and services; no restarts.
	_brew_commit() {
		_log "commit" "brew" "bundle dump $HOMEBREW_BUNDLE_FILE"
		if ((VERBOSE)); then
			_run brew bundle dump --file "$HOMEBREW_BUNDLE_FILE" --tap --formula --cask --services --no-restart --force --verbose
		else
			_run brew bundle dump --file "$HOMEBREW_BUNDLE_FILE" --tap --formula --cask --services --no-restart --force
		fi
	}
	# _chezmoi_commit: confirm and add changes to source state per managed file.
	# - iterates managed files list, shows diff, then adds on confirm.
	_chezmoi_commit() {
		_log "commit" "chezmoi" "confirm to add managed files"
		local file=""
		while IFS= read -r -d '' file; do
			[[ -n "$file" ]] || continue
			_confirm "Add chezmoi changes?" "$file" && _run chezmoi add "$file" || true
		done < <(chezmoi managed --include=files --nul-path-separator -p absolute)
	}

	if _exclude chezmoi || ! _has chezmoi; then
		_die "commit" "chezmoi" "chezmoi missing or excluded; cannot commit"
	fi
	git_stash
	if ! _exclude brew && _has brew; then _brew_commit; fi
	if ! _exclude chezmoi && _has chezmoi; then _chezmoi_commit; fi
	git_commit
}

# push: push metadata to the remote repo.
# - uses git push inside the chezmoi repo.
push() {
	# _chezmoi_push: push chezmoi repo to remote.
	# - runs git push via chezmoi wrapper.
	_chezmoi_push() {
		local repo
		repo="$(chezmoi git -- config --get remote.origin.url 2>/dev/null || echo unknown)"
		local ahead
		ahead="$(chezmoi git -- rev-list --count @{u}..HEAD 2>/dev/null || echo 0)"
		if [[ "$ahead" == "0" ]]; then
			_log "push" "chezmoi" "no changes to push"
			return 0
		fi
		_log "push" "chezmoi" "push branch ${BRANCH} to ${repo}"
		_run chezmoi git -- push
	}

	if ! _exclude chezmoi && _has chezmoi; then _chezmoi_push; fi
}

# main: parse CLI args, set flags, and run selected steps.
# - supports combined short flags (e.g., -cpua).
main() {
	[[ $# -ge 1 ]] || {
		_usage
		exit 2
	}

	local -a steps=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
		--help)
			_usage
			exit 0
			;;
		--verbose)
			VERBOSE=1
			shift
			;;
		--debug)
			DEBUG=1
			shift
			;;
		--confirm)
			CONFIRM=1
			shift
			;;
		--branch)
			shift
			[[ $# -ge 1 ]] || _die "--branch requires BRANCH"
			BRANCH="$1"
			shift
			;;
		--exclude)
			shift
			[[ $# -ge 1 ]] || _die "--exclude requires EXCLUDE"
			if [[ -z "$EXCLUDES" ]]; then EXCLUDES="$1"; else EXCLUDES="${EXCLUDES},$1"; fi
			shift
			;;

		--bootstrap | -b)
			steps+=("b")
			shift
			;;
		--update | -u)
			steps+=("u")
			shift
			;;
		--apply | -a)
			steps+=("a")
			shift
			;;
		--prune | -x)
			steps+=("x")
			shift
			;;
		--commit | -c)
			steps+=("c")
			shift
			;;
		--push | -p)
			steps+=("p")
			shift
			;;

		-[bcpuax]*)
			local arg="$1" seq="$1"
			[[ "$seq" == -* ]] && seq="${seq#-}"
			[[ "$seq" =~ ^[bcpuax]+$ ]] || _die "invalid sequence token: $arg"

			local i ch
			for ((i = 0; i < ${#seq}; i++)); do
				ch="${seq:i:1}"
				steps+=("$ch")
			done
			shift
			;;

		*)
			_die "unknown argument: $1"
			;;
		esac
	done

	if ((DEBUG)); then
		VERBOSE=1
		set -x
	fi

	if ((${#steps[@]} > 0)); then
		local s
		for s in "${steps[@]}"; do
			case "$s" in
			b) bootstrap ;;
			u) update ;;
			a) apply ;;
			x) prune ;;
			c) commit ;;
			p) push ;;
			*) _die "unknown step: $s" ;;
			esac
		done
	fi
}

main "$@"
